# Grammar Parser

GrammarParser 是一个通用文法解析工具，其设计原理严格采用《编译原理》中说明的内容，目前已经完整支持解析 LR(1) 类型文法，LR(1) 文法也是诸多上下文无关文法中最为复杂的文法，其复杂程度主要表现在解析生成的中间状态集庞大、数量众多，而支持这样的文法解析的好处在于，对于较为复杂的文法，本工具都能更好、更普适、更准确地进行支持。对于其他类型的文法，设计文法时需要更多的考虑与回避（比如 LL(1) 类型语法需要文法中不能存在左递归生成式），因此优先实现一种最为强大的语法解析类型，可以极大地方便后续流程的设计与实现。后续，依然会拓展实现对 SLR(1)、LALR 类型文法的支持，他们在用于对一些文法进行分析时，状态集数量会明显降低，但同时支持的文法也有一定的限制，后续实现时会展开说明。

## 使用说明

```bash
./GrammarParser path/to/grammar/file
```

即可按照 LR(1) 语法来进行语法解析，执行过程主要包括：计算文法中非终结符的 FIRST 集、生成文法对应的 LR(0) 项集合、计算 LR(1) 项集合、计算每个 LR(1) 项集合的闭包、计算 LR(1) 项集合闭包间的转移函数、填充 LR(1) 文法动作表（ActionTable，包括移入、规约动作）。其中填充动作表用于检查是否存在 移入/移入 冲突、移入/规约 冲突，如果不存在冲突项，就认为文法本身可以按照 LR(1) 文法来进行分析，也就是说这是一个 LR(1) 文法。

## 示例

- 文法 4.49

```text
S' -> S
S -> L = R
S -> R
L -> * R
L -> id
R -> L
```

文法 4.49 本身不是一个 SLR(1) 文法，但它是一个 LR(1) 文法。其 LR(1) 关键分析信息如下：

```text
FIRST SET:
L: * id
R: * id
S: * id
S': * id

STATE CLOSURE:

I0:
[S' -> ·S, #]
[S -> ·L = R, #]
[S -> ·R, #]
[L -> ·* R, =]
[L -> ·id, =]
[R -> ·L, #]
[L -> ·* R, #]
[L -> ·id, #]

I1:
[L -> ·* R, =]
[L -> ·id, =]
[R -> ·L, #]
[L -> ·* R, #]
[L -> ·id, #]
[L -> * ·R, =]
[L -> * ·R, #]
[R -> ·L, =]

I2:
[S -> L ·= R, #]
[R -> L·, #]

I3:
[S -> R·, #]

I4:
[S' -> S·, #]

I5:
[L -> id·, =]
[L -> id·, #]

I6:
[R -> L·, #]
[R -> L·, =]

I7:
[L -> * R·, =]
[L -> * R·, #]

I8:
[R -> ·L, #]
[L -> ·* R, #]
[L -> ·id, #]
[S -> L = ·R, #]

I9:
[R -> ·L, #]
[L -> ·* R, #]
[L -> ·id, #]
[L -> * ·R, #]

I10:
[R -> L·, #]

I11:
[S -> L = R·, #]

I12:
[L -> id·, #]

I13:
[L -> * R·, #]

ACTION TABLE:
0:	*: 1	L: 2	R: 3	S: 4	id: 5
1:	*: 1	L: 6	R: 7	id: 5
2:	#: -6	=: 8
3:	#: -3
4:	#: -1
5:	#: -5	=: -5
6:	#: -6	=: -6
7:	#: -4	=: -4
8:	*: 9	L: 10	R: 11	id: 12
9:	*: 9	L: 10	R: 13	id: 12
10:	#: -6
11:	#: -2
12:	#: -5
13:	#: -4
```

- 文法 4.55

```text
S' -> S
S -> C C
C -> c C
C -> d
```

文法 4.55 本身是一个 LR(1) 文法，同时它也是一个 SLR(1) 文法。简言之，SLR(1) 文法一定是 LR(1) 文法，反之则未必。其 LR(1) 关键信息分析如下：

```text
FIRST SET:
C: c d
S: c d
S': c d

STATE CLOSURE:

I0:
[S' -> ·S, #]
[S -> ·C C, #]
[C -> ·c C, c/d]
[C -> ·d, c/d]

I1:
[S -> C ·C, #]
[C -> ·c C, #]
[C -> ·d, #]

I2:
[S' -> S·, #]

I3:
[C -> ·c C, c/d]
[C -> ·d, c/d]
[C -> c ·C, c/d]

I4:
[C -> d·, c/d]

I5:
[S -> C C·, #]

I6:
[C -> c ·C, #]
[C -> ·c C, #]
[C -> ·d, #]

I7:
[C -> d·, #]

I8:
[C -> c C·, c/d]

I9:
[C -> c C·, #]

ACTION TABLE:
0:	C: 1	S: 2	c: 3	d: 4
1:	C: 5	c: 6	d: 7
2:	#: -1
3:	C: 8	c: 3	d: 4
4:	c: -4	d: -4
5:	#: -2
6:	C: 9	c: 6	d: 7
7:	#: -4
8:	c: -3	d: -3
9:	#: -3
```
